[TOC]



# 6.7   22:52  AJax

## AJax定义

Ajax（Asynchronous JavaScript and XML）是一种用于创建交互式网页应用程序的技术。它允许在不重新加载整个页面的情况下，通过在后台与服务器进行数据交换，更新部分页面内容。通过Ajax，可以实现异步加载数据、发送数据、更新页面等功能，从而提升用户体验和网页性能



## 懒加载和按需加载

懒加载（Lazy Loading）和按需加载（On-Demand Loading）都是优化网页性能和用户体验的技术手段，它们可以减少初始加载的内容量，提高页面的加载速度。

懒加载是指延迟加载页面中的某些内容，只在用户需要访问到它们时再进行加载。典型的应用场景是图片懒加载，当页面中存在大量图片时，可以将图片的真实地址保存在自定义属性中（例如`data-src`），初始时使用占位图或者空的`src`属性。当图片进入可视区域时，通过JavaScript动态加载真实的图片地址，实现图片的懒加载。这样可以减少初始页面加载的图片数量，提高页面的加载速度，并且节省带宽。

按需加载是指根据用户的需求，在特定情况下才加载某些资源或功能。例如，在网页中包含大量的JavaScript代码，可以将其中的某些功能代码按需加载。当用户执行特定操作或进入特定页面时，再动态地加载相关的JavaScript文件。这样可以减少初始页面加载的JavaScript代码量，加快页面渲染速度。按需加载还可以应用于其他类型的资源，例如CSS文件、字体文件、视频等。

无论是懒加载还是按需加载，它们都需要使用JavaScript来实现。通过合理地应用懒加载和按需加载，可以提高网页的加载速度、降低带宽消耗，并改善用户的交互体验。



### 操作步骤

>
>
>当涉及到优化网页性能和用户体验时，懒加载和按需加载是两种常用的技术手段。它们可以帮助减少初始页面加载的内容量，提高页面的加载速度，并在用户需要时才加载额外的资源或功能。
>
>懒加载（Lazy Loading）是一种延迟加载技术，它将页面中某些内容的加载推迟到用户实际需要访问到它们的时候才进行。常见的应用场景是图片懒加载，其中图片的加载被延迟到图片进入用户视野（即滚动到可见区域）之前。这样做可以减少初始加载的图片数量，提高页面的加载速度，并节省带宽。懒加载通常通过以下步骤实现：
>
>1. 在初始加载时，使用占位图或者空的`src`属性替代真实图片地址。
>2. 将真实的图片地址保存在自定义属性中，例如`data-src`。
>3. 使用JavaScript监测滚动事件，当图片进入用户视野时，将真实的图片地址赋值给`src`属性，从而触发图片的加载。
>
>除了图片懒加载，还可以将其他类型的内容应用懒加载，如延迟加载视频、音频、地图等。懒加载可以通过现有的JavaScript库或框架来实现，例如使用Intersection Observer API或使用第三方库如Lazysizes、Lazyload等。
>
>按需加载（On-Demand Loading）是根据用户的需求，有选择地加载特定的资源或功能。它可以用于减少初始页面加载时的代码量，提高页面渲染速度。按需加载的应用场景包括：
>
>1. JavaScript按需加载：将页面中的某些功能代码分割成多个模块，在特定的操作或进入特定页面时，动态地加载相应的JavaScript模块。这可以通过模块打包工具（如Webpack、Rollup等）和异步加载的方式实现，例如使用动态`import()`函数或使用require.js等库。
>2. CSS按需加载：将页面中的某些样式文件分割成多个模块，根据需要动态加载对应的CSS文件。这可以通过JavaScript来实现，动态创建`<link>`元素并将其添加到页面中。
>3. 图片按需加载：当用户需要查看更多图片时，动态加载额外的图片资源。这可以通过JavaScript来实现，例如在点击"加载更多"按钮时，异步请求并加载更多的图片。
>
>通过懒加载和按需加载，可以有效地减少初始加载的内容量，提高页面的加载速度和响应性，从而改善用户的交互体验。但需要注意的是，合理地使用这些技术时要权衡好用户需求和性能优化的平衡，以确保
>
>页面仍然能够提供所需的功能和内容。



## xml

>XML（eXtensible Markup Language）是一种用于描述数据的标记语言。它被设计用于传输和存储数据，具有自我描述性、可扩展性和跨平台性的特点。
>
>XML使用标签来标识数据元素，并使用起始标签和结束标签来定义元素的范围。标签可以嵌套，形成层次结构，表示数据之间的关系。例如，下面是一个简单的XML示例：
>
>```xml
><person>
>  <name>John Doe</name>
>  <age>30</age>
>  <address>
>    <city>New York</city>
>    <state>NY</state>
>  </address>
></person>
>```
>
>在上面的示例中，`person`是最外层的元素，它包含了`name`、`age`和`address`等子元素。每个元素都由起始标签和结束标签包围，并且可以包含文本或其他元素。
>
>XML还可以使用属性来提供关于元素的附加信息。属性位于起始标签中，并使用键值对的形式表示。例如，可以将上述示例中的`person`元素改为包含属性的形式：
>
>```xml
><person id="1">
>  <name>John Doe</name>
>  <age>30</age>
>  <address>
>    <city>New York</city>
>    <state>NY</state>
>  </address>
></person>
>```
>
>在这个示例中，`person`元素具有一个名为`id`的属性，其值为`1`。
>
>XML可以用于在不同平台和应用程序之间传递和共享数据。它是一种通用的数据格式，被广泛用于Web服务、配置文件、数据交换等领域。许多编程语言和技术都提供了对XML的解析和处理功能，例如使用DOM（Document Object Model）、SAX（Simple API for XML）、XPath等。
>
>需要注意的是，随着发展和演进，JSON（JavaScript Object Notation）等其他数据交换格式在许多场景下更为流行和广泛使用，因为它们更简洁、易于理解和处理。然而，XML仍然在一些特定的应用和标准中扮演着重要的角色。



JSON

>JSON（JavaScript Object Notation）不是XML的迭代版本，而是一种与XML相互竞争的数据交换格式。JSON的设计目标是提供一种简洁、易于理解和处理的数据表示形式。
>
>相比于XML，JSON具有以下特点：
>
>1. 简洁性：JSON使用简洁的语法来表示数据，相对于XML而言，它的表示形式更为紧凑。JSON使用花括号（{}）表示对象，方括号（[]）表示数组，以及使用逗号和冒号来分隔键值对等。
>
>2. 可读性：JSON的结构和值的表示形式更接近于常见的编程语言中的数据结构，使得它更易于阅读和理解。
>
>3. 解析效率：相对于XML而言，JSON的解析速度更快，因为JSON的结构相对简单，解析器实现起来更高效。
>
>4. 与JavaScript的紧密关联：JSON的语法与JavaScript对象字面量的表示形式非常相似，这使得它在与JavaScript代码的交互和处理上更为方便。
>
>由于这些优势，JSON在Web开发中得到了广泛应用。它成为了一种常见的数据交换格式，用于传输和存储结构化数据，与后端服务器进行数据交互，以及在不同平台和应用程序之间进行数据传递。许多编程语言都提供了对JSON的解析和序列化支持。
>
>虽然JSON在许多方面替代了XML的使用，但XML仍然在某些领域中发挥作用，特别是在一些遗留系统、标准和特定行业的规范中。在某些情况下，XML的自描述性和扩展性仍然是其优势。因此，选择JSON还是XML取决于具体的应用需求和使用环境。



## xml和json的使用场景和优缺点

>
>
>XML和JSON都是常见的数据交换格式，它们在不同的场景和需求中有各自的优势和适用性。
>
>XML的使用场景：
>- Web服务：XML常用于Web服务的数据传输和交互。它可以描述复杂的数据结构和嵌套关系，并提供灵活的扩展性。
>- 配置文件：许多应用程序使用XML格式的配置文件，以便存储和管理应用程序的设置和参数。
>- 数据存储和持久化：XML可以用于将数据存储到文件或数据库中，以及进行数据的持久化。
>- 标准和规范：某些行业和领域（如电子数据交换、文档标记等）使用XML作为数据交换的标准格式。
>
>XML的优点：
>- 自描述性：XML使用标签和元素来描述数据，具有自我描述的特性，使数据结构更易于理解和解析。
>- 扩展性：XML具有良好的扩展性，可以定义自定义的标签和数据结构，适应不同的需求和应用场景。
>- 成熟的技术生态系统：XML有丰富的工具和库支持，许多编程语言都提供了对XML的解析和处理功能。
>
>XML的缺点：
>- 冗余和冗长：相对于JSON而言，XML的表示形式较为冗余，需要更多的字符来描述同样的数据结构，导致文件大小较大。
>- 解析和处理复杂性：XML的解析和处理相对复杂，需要使用特定的解析器或库来解析XML文档，并对数据进行操作和处理。
>
>JSON的使用场景：
>- Web API：JSON是Web API中常用的数据格式，用于在客户端和服务器之间进行数据交换。
>- 前端开发：JSON与JavaScript对象字面量的表示形式类似，非常适合在前端开发中使用，可以方便地与JavaScript代码进行交互。
>- 移动应用程序：由于JSON的轻量性和解析效率，它常用于移动应用程序的数据传输和存储。
>
>JSON的优点：
>- 简洁性和紧凑性：JSON的表示形式相对于XML更为简洁，使用更少的字符来表示相同的数据结构，从而减少了数据传输的大小。
>- 解析和处理效率：由于JSON的结构相对简单，解析速度比XML更快，对于处理大量数据的应用场景更加高效。
>- 与JavaScript的紧密集成：JSON的语法与JavaScript对象字面量的表示形式相似，与JavaScript代码的交互和处理更加方便。
>
>JSON的缺点：
>- 缺乏扩展性：相对于XML而言，JSON的扩展性较差，不容易在已
>
>有的结构中添加新的字段或数据。
>- 不支持注释：JSON规范不支持注释，这在某些情况下可能不方便进行文档的解释和说明。
>
>选择使用XML还是JSON取决于具体的需求、应用场景和技术栈。如果需要自描述性、灵活性和扩展性，则XML可能更适合。如果追求简洁性、解析效率和与JavaScript的紧密集成，则JSON可能更合适。



## SEO（Search Engine Optimization，搜索引擎优化）

>
>
>搜索引擎中的排名和可见性的过程指的是通过一系列的优化策略和技术，使网站在搜索引擎的自然（非付费）搜索结果中获得更高的排名，从而提高网站在搜索引擎中的可见性。
>
>搜索引擎会根据一定的算法和规则对网页进行评估和排序，以确定它们在搜索结果中的排名。搜索引擎的目标是向用户提供与其搜索查询相关且高质量的网页结果。
>
>通过SEO（Search Engine Optimization，搜索引擎优化）的技术和策略，网站可以尝试提高在搜索引擎中的排名和可见性，从而增加网站的曝光度、流量和潜在用户。
>
>在这个过程中，网站优化的关键是了解搜索引擎的工作原理和用户行为，并对网站的内容、结构和其他因素进行相应的优化。一些常见的SEO技术包括关键词优化、内容优化、网站结构优化、外部链接建设等。
>
>当一个网站在搜索引擎中的排名较高时，它会在相关的搜索查询中出现在较高的位置，这就增加了网站被用户访问和点击的机会，提高了网站的可见性。换句话说，排名较高的网站更容易被用户注意到，点击并访问。
>
>通过持续的SEO工作，网站可以逐渐提高在搜索引擎中的排名和可见性，从而获得更多的有机流量和更好的网络曝光。这对于网站的品牌建设、业务增长和在线成功都具有重要意义。



### 常见的SEO技术和策略

>SEO（Search Engine Optimization）是指优化网站以提高在搜索引擎中的排名和可见性的过程。它是一种通过优化网站的内容、结构和其他因素来吸引搜索引擎的注意并提高排名的方法。
>
>搜索引擎是互联网用户获取信息的主要工具，因此在搜索结果中获得更高的排名可以带来更多的有机流量和曝光机会。SEO的目标是使网站在搜索引擎的自然（非付费）搜索结果中获得更高的排名，从而吸引更多的访问者。
>
>以下是一些常见的SEO技术和策略：
>
>1. 关键词优化：通过研究和选择与网站内容相关的关键词，并在网站的标题、页面内容、URL、图片标签等位置合理地使用这些关键词，以增加搜索引擎对网站的关注和理解。
>
>2. 内容优化：创建高质量、有价值的内容，使其与目标受众的需求相匹配，并优化页面结构、标题标签、段落标签等，以提供清晰且易于阅读的内容。
>
>3. 网站结构优化：确保网站的导航结构清晰，并使用友好的URL结构，方便搜索引擎和用户浏览和理解网站的内容。
>
>4. 外部链接建设：通过获取来自其他高质量网站的外部链接，增加网站的权威性和可信度，从而提高搜索引擎对网站的排名。
>
>5. 移动优化：优化网站以适应移动设备的浏览，包括响应式设计、快速加载速度和易用的移动界面。
>
>6. 社交媒体整合：与社交媒体平台结合，分享网站内容并增加社交媒体上的曝光度和链接。
>
>SEO的优点：
>- 增加有机流量：通过优化网站以获得更好的搜索引擎排名，可以带来更多的有机流量，即来自搜索引擎的自然访问者。
>- 提高网站可见性：在搜索引擎中获得更高的排名，可以增加网站的曝光度和知名度，吸引更多的用户关注。
>- 长期效益：一旦实施了有效的SEO策略，它可以为网站带来长期的可见性和流量，相对于付费广告而言，SEO的效益更持久。
>
>SEO的挑战和注意事项：
>- 竞争激烈：许多网站都在争夺搜索引擎排名的前几位，因此在
>
>竞争激烈的市场中获得较高的排名可能需要更多的努力和时间。
>- 持续更新和监测：搜索引擎算法会不断更新，因此SEO需要持续地进行优化和监测，以适应变化的搜索引擎环境。
>- 避免黑帽SEO：使用欺诈性和违规手段来提高排名，如隐藏关键词、购买链接等，可能导致搜索引擎的惩罚和排名下降。
>
>需要注意的是，SEO是一个复杂的领域，它需要不断学习和实践，同时也受到搜索引擎算法的影响。建议在进行SEO时参考权威的指南和最佳实践，并保持对行业动态的关注。



## seo和爬虫之间的关系

>
>
>SEO（Search Engine Optimization）和爬虫之间存在密切的关系。理解这两者之间的关系对于了解搜索引擎工作原理和进行网站优化非常重要。
>
>SEO是一系列的优化策略和技术，旨在提高网站在搜索引擎中的排名和可见性，从而吸引更多的有机流量和用户访问。而搜索引擎爬虫（也称为网络爬虫或蜘蛛）是搜索引擎的一部分，负责自动地浏览和索引互联网上的网页。
>
>爬虫通过访问网站的链接，并逐个解析和抓取网页的内容，建立搜索引擎的索引数据库。当用户在搜索引擎中输入查询时，搜索引擎会根据索引数据库中的信息，根据一定的算法和规则来匹配最相关的网页，并以特定的排名方式呈现给用户。
>
>因此，对于网站的SEO来说，了解和理解搜索引擎爬虫的行为和需求非常重要。以下是SEO和爬虫之间的关系：
>
>1. 网站可访问性：爬虫需要能够访问和抓取网站的内容。因此，优化网站的可访问性，确保没有阻碍爬虫的技术问题（如错误的robots.txt文件、无法被抓取的页面等），是SEO的关键之一。
>
>2. 内容优化：搜索引擎爬虫会解析和理解网页的内容。通过优化网站的内容，使用关键词、标题标签、段落标签等，可以帮助爬虫更好地理解和索引网页。
>
>3. 网站结构优化：良好的网站结构和导航可以帮助爬虫更有效地抓取和索引网页。优化网站的URL结构、内部链接、网站地图等，可以提升爬虫对网站的理解和索引效果。
>
>4. 外部链接建设：爬虫通过外部链接发现和索引网页。获得来自其他高质量网站的外部链接可以增加爬虫抓取网页的机会，并提高网站的权威性和可信度。
>
>综上所述，SEO和爬虫是相互关联的。通过对网站进行合理的SEO优化，可以帮助爬虫更好地理解和索引网页，从而提高网站在搜索引擎中的排名和可见性。同时，理解搜索引擎爬虫的行为和需求，可以指导网站的优化策略和技术实施。



### 爬虫对seo起到的作用

>爬虫对SEO起到重要作用的方面主要包括以下几点：
>
>1. 网站索引：爬虫负责浏览和抓取互联网上的网页，并建立搜索引擎的索引数据库。通过爬虫的工作，搜索引擎可以了解网站的存在、内容和结构。这使得网站能够在搜索引擎中被发现和索引，从而提高在搜索结果中的可见性。
>
>2. 网站可访问性：爬虫需要能够访问和抓取网站的内容。如果网站存在可访问性问题（如错误的robots.txt文件、无法被抓取的页面等），搜索引擎爬虫将无法正确抓取和索引网站的内容。因此，确保网站的可访问性对于爬虫能够正确地抓取网站内容至关重要。
>
>3. 内容解析和理解：搜索引擎爬虫会解析和理解网页的内容，以便将其与用户的搜索查询进行匹配。通过对网站内容进行优化，使用关键词、标题标签、段落标签等，可以帮助爬虫更好地理解和索引网页。这样，当用户搜索与网站内容相关的关键词时，网站更有可能出现在搜索结果中。
>
>4. 网站结构和导航：良好的网站结构和导航对于爬虫的抓取和索引非常重要。通过优化网站的URL结构、内部链接、网站地图等，可以帮助爬虫更有效地抓取和索引网页。良好的结构和导航也有助于提供更好的用户体验，进一步提高网站的SEO效果。
>
>综上所述，爬虫在SEO中起到了关键的作用。它们负责发现、抓取和索引网页，将网站内容呈现给用户。通过理解爬虫的行为和需求，并通过合理的网站优化，可以提高网站在搜索引擎中的排名和可见性，从而吸引更多的有机流量和用户访问。





## 扩展知识： 爬虫

>
>
>是的，利用爬虫整合网站的内容可以说是在已有的爬虫基础上再次使用爬虫技术。
>
>通常情况下，搜索引擎的爬虫会自动地抓取和索引网站的内容，以建立搜索引擎的索引数据库。这个过程是由搜索引擎自身控制和执行的，网站所有者无法直接控制爬虫的行为。
>
>然而，有时候需要从多个网站或不同来源的网页中获取特定的内容，并将其整合到一个统一的平台或应用程序中。这时候，可以使用自定义的爬虫来定向抓取这些网页，并从中提取所需的内容。
>
>利用自定义的爬虫进行内容整合的过程可以包括以下步骤：
>1. 根据需求确定需要抓取的网页和内容。
>2. 编写自定义的爬虫程序，用于定向抓取这些网页并提取所需的内容。
>3. 对抓取到的内容进行清洗、处理和整合，以符合所需的格式和结构。
>4. 将整合后的内容导入到目标平台或应用程序中，供用户访问和使用。
>
>这种利用自定义的爬虫进行内容整合的方式，可以根据特定的需求和目标灵活地抓取和整合网页内容，以满足定制化的需求。



## 搜索引擎服务器通过爬虫技术返回用户索引数据

搜索引擎服务器返回给用户的数据是经过爬虫数据库处理得出的。

搜索引擎的工作过程包括爬取、索引和检索。爬虫负责抓取互联网上的网页，并将抓取到的网页内容存储在搜索引擎的数据库中。这个数据库通常称为索引数据库，其中包含了爬虫抓取到的网页的信息。

当用户在搜索引擎中输入查询时，搜索引擎会根据用户的查询内容，通过检索索引数据库中的信息，找到与查询相关的网页。搜索引擎会使用一系列的算法和规则来匹配最相关的网页，并将搜索结果呈现给用户。

因此，搜索引擎服务器返回给用户的数据是通过搜索引擎的爬虫数据库得出的。爬虫抓取的网页内容被索引并存储在数据库中，用户的查询会在这个数据库中进行匹配和检索，最终得到相关的搜索结果返回给用户。

值得注意的是，搜索引擎的数据库会定期更新，以反映互联网上新的网页和内容的变化。这意味着搜索引擎服务器返回给用户的数据可能是最新的索引数据库中的内容。





## HTTP

HTTP（Hypertext Transfer Protocol）是一种用于在网络中传输超文本数据的协议。它是基于客户端-服务器模型的协议，用于在Web浏览器和Web服务器之间进行通信。

HTTP的工作原理如下：

1. 客户端发起请求：客户端（通常是Web浏览器）向服务器发送HTTP请求。请求包括请求方法（如GET、POST等）、URL、请求头部（包含有关请求的附加信息）以及可选的请求体（对于某些请求方法，如POST）。

2. 服务器处理请求：服务器接收到客户端发送的HTTP请求，并根据请求的URL和方法执行相应的操作。这可能涉及读取文件、处理数据、执行脚本等。

3. 服务器发送响应：服务器根据请求的处理结果生成HTTP响应。响应包括响应状态码（用于表示请求成功或失败的状态）、响应头部（包含有关响应的元数据）以及可选的响应体（包含服务器返回的数据）。

4. 客户端接收响应：客户端接收到服务器发送的HTTP响应，并根据响应进行相应的处理。这可能包括显示响应的内容、执行跳转、解析数据等。

HTTP的特点包括：

- 简单性：HTTP使用简单的文本格式进行通信，易于理解和调试。
- 无状态性：HTTP是无状态协议，服务器不会保留客户端请求的状态信息。每个请求都是独立的，服务器只根据每个请求进行响应。
- 可扩展性：HTTP允许通过添加自定义的请求方法、头部和状态码等进行扩展。
- 明文传输：HTTP默认使用明文传输，数据在传输过程中可能被窃听或篡改。可以通过使用HTTPS（HTTP Secure）进行加密和安全传输。

HTTP在Web应用中扮演着重要的角色，它使得浏览器可以向服务器请求网页、图像、视频和其他资源，并将其呈现给用户。同时，HTTP也被用于Web API的实现，用于客户端与服务器之间的数据交换。



### HTTP请求报文

>
>
>HTTP请求报文由请求行（Request Line）、请求头部（Headers）和请求体（Body）组成。下面是HTTP请求报文的一般格式和常见的参数：
>
>1. 请求行（Request Line）：
>   - 请求方法（Method）：表示客户端希望服务器执行的操作，常见的方法有GET、POST、PUT、DELETE等。
>   - 请求目标（Request Target）：表示请求的目标资源，可以是一个URL路径或一个绝对URL。
>   - 协议版本（HTTP Version）：指定所使用的HTTP协议的版本，如HTTP/1.1。
>
>2. 请求头部（Headers）：
>   - Host：指定目标服务器的主机名和端口号。
>   - User-Agent：标识客户端应用程序或浏览器的名称和版本号。
>   - Accept：指定客户端可接受的响应内容类型。
>   - Content-Type：指定请求体中的数据类型。
>   - Cookie：包含在客户端上次收到的服务器设置的Cookie信息。
>   - Authorization：用于在请求中传递身份验证凭据等。
>
>3. 请求体（Body）：
>   - 对于GET请求，请求体通常为空。
>   - 对于POST请求，请求体可以包含需要传递给服务器的数据，如表单字段、JSON数据等。
>
>在实际的HTTP请求中，可以通过在请求头部中添加自定义的参数来传递额外的信息。例如，可以添加自定义的头部字段来标识请求的特定要求或附加的上下文信息。
>
>例如，下面是一个使用POST方法的HTTP请求报文示例：
>
>```
>POST /api/users HTTP/1.1
>Host: example.com
>User-Agent: Mozilla/5.0
>Content-Type: application/json
>Authorization: Bearer xxxxxxxxxxxxxxxx
>
>{
>  "name": "John Doe",
>  "email": "johndoe@example.com"
>}
>```
>
>在这个示例中，请求方法为POST，请求目标为`/api/users`，使用的HTTP协议版本为HTTP/1.1。请求头部包括Host、User-Agent、Content-Type和Authorization等字段。请求体是一个JSON格式的数据，包含了名为"name"和"email"的字段及其对应的值。
>
>需要注意的是，具体的请求报文格式和参数可以根据实际的需求和使用的HTTP框架、库或工具而有所不同。上述示例只是一种常见的格式，实际应用中可能会有其他定制化的参数和格式。



###  通过请求报文可以获得什么，如你所举的例子

通过请求报文，可以获得以下信息：

1. 请求方法（Method）：请求报文中的请求方法字段指示了客户端希望服务器执行的操作，例如GET、POST、PUT、DELETE等。这告诉服务器应该采取何种行动来处理请求。

2. 请求目标（Request Target）：请求报文中的请求目标字段指示了请求的目标资源，可以是一个URL路径或一个绝对URL。它告诉服务器应该访问哪个资源来满足请求。

3. 请求头部（Headers）：请求报文中的请求头部包含了客户端向服务器传递的附加信息，用于控制请求的行为、传递认证凭据、指定所需的内容类型等。一些常见的请求头部字段包括Host、User-Agent、Accept、Content-Type等。这些头部字段提供了关于请求的上下文和要求的详细信息。

4. 请求体（Body）：请求报文中的请求体用于传递一些需要发送给服务器的数据，例如表单字段、JSON数据、文件等。它通常在POST请求中使用，以便向服务器发送数据。

通过解析请求报文，服务器可以了解客户端的请求意图、所需资源、附加信息和数据。服务器根据这些信息来处理请求，并生成相应的响应报文返回给客户端。

在前面给出的示例中，通过请求报文可以获得以下信息：
- 请求方法为POST，表示客户端希望创建新的用户。
- 请求目标为`/api/users`，告诉服务器应该处理关于用户资源的请求。
- 请求头部中的User-Agent指示了客户端的浏览器或应用程序。
- Content-Type字段指示了请求体中的数据类型为JSON，服务器可以据此解析请求体中的JSON数据。
- Authorization字段可能包含了身份验证的凭据，以便服务器验证客户端的身份。

服务器可以根据这些信息来判断客户端的意图，对请求进行处理，验证身份，解析请求体中的数据，并生成相应的响应返回给客户端。



## post请求通过提交用户账户密码表单字段至服务器进行验证

登录界面通常使用POST请求来提交用户输入的账号和密码信息至服务器进行验证。用户在登录界面输入账号和密码后，通过点击提交按钮，触发表单的提交操作。

提交操作会将表单中的数据封装在POST请求的请求体中，并将请求发送给服务器。服务器接收到这个POST请求后，可以解析请求体中的数据，获取到用户输入的账号和密码信息。

服务器在收到登录请求后，通常会进行一系列的操作，包括验证账号密码是否匹配、检查账号是否存在、检查密码是否正确等。这可能涉及到与数据库的交互，比如查询用户信息、对比密码等。通过这些验证步骤，服务器可以确定用户输入的账号和密码是否正确。

根据验证结果，服务器会生成相应的响应返回给客户端。如果验证成功，服务器可以返回一些用户特定的数据或者授权信息，用于用户的后续访问。如果验证失败，服务器可能会返回一条错误消息，提示用户输入的账号或密码不正确。

总结来说，登录界面使用POST请求来将用户输入的账号和密码提交至服务器进行验证。服务器根据接收到的数据，与数据库中的数据进行比对和验证，最终决定是否授予用户访问权限。这样可以保证用户的登录过程更加安全和可靠。



## 多租户架构

是的，一个后台通常可以适用于多个前台。这种架构通常被称为多租户（Multi-Tenant）架构，其中一个后台系统可以为多个前台提供服务。

在多租户架构中，后台系统是共享的，它为多个前台提供数据处理和业务逻辑的功能。每个前台可能具有不同的用户界面、功能需求和配置，但它们共享同一个后台系统和数据库。

这种架构的优势包括：

1. 节省开发和维护成本：通过共享后台系统，减少了重复开发和维护多个独立的后台系统的工作量。

2. 数据一致性：所有的前台共享同一个后台数据库，确保数据的一致性和准确性。

3. 简化系统管理：只需要管理和维护一个后台系统，降低了系统管理的复杂性。

4. 可扩展性：后台系统可以根据需要进行扩展，以满足不同前台的需求。

然而，多租户架构也有一些挑战和注意事项，包括：

1. 数据隔离：需要确保不同前台之间的数据相互隔离，避免数据泄漏或冲突。

2. 安全性：需要确保前台之间的数据和操作安全，防止未经授权的访问。

3. 性能考虑：在处理多个前台的请求时，需要考虑系统的性能和资源利用率。

4. 定制化需求：不同前台可能有定制化的需求，需要灵活的架构和扩展机制来满足这些需求。

综上所述，一个后台系统通常可以为多个前台提供服务，通过多租户架构实现数据和功能的共享，从而提高开发效率和系统管理的便利性。



## 多站点架构

是的，多个前台可以对应一个后台。这种架构被称为多站点（Multi-Site）架构，其中一个后台系统可以管理和服务多个前台站点。

在多站点架构中，每个前台站点可能具有不同的域名、品牌、设计和用户界面，但它们共享同一个后台系统和数据库。每个前台站点在后台系统中被视为一个独立的实体，具有各自的配置、内容、用户等。

这种架构的优势包括：

1. 统一的后台管理：通过共享后台系统，可以在同一个界面上管理和维护多个前台站点，包括内容管理、用户管理、配置管理等。

2. 代码复用和维护简化：由于多个前台站点共享同一个后台系统，可以复用和共享代码、功能和模块，减少重复开发和维护工作。

3. 数据共享和一致性：所有的前台站点共享同一个后台数据库，确保数据的一致性和准确性。

4. 系统扩展性：后台系统可以根据需要进行扩展，以支持更多的前台站点。

然而，多站点架构也有一些挑战和注意事项，包括：

1. 域名和品牌管理：需要灵活的域名和品牌管理机制，以便为不同的前台站点设置不同的域名和品牌标识。

2. 安全性和权限控制：需要确保不同前台站点之间的数据和操作安全，实施适当的权限控制。

3. 性能和资源管理：在处理多个前台站点的请求时，需要考虑系统的性能和资源利用率，以确保各个站点的响应速度和用户体验。

4. 定制化需求：不同前台站点可能有定制化的需求，需要灵活的架构和扩展机制来满足这些需求。

综上所述，多个前台站点可以对应一个后台系统，通过多站点架构实现管理多个站点的统一性和代码复用。这种架构适用于需要管理多个相关站点，并在后台系统中共享数据和功能的场景。





# 6.9

## 扩展知识- 框架

框架（Framework）是指在特定领域中，为了解决一类问题而设计和开发的一套半成品软件或工具的集合。它提供了一种基础结构和约定，帮助开发者更高效地构建应用程序。

可以将框架类比为一个搭建应用程序的脚手架，它提供了一些基础设施和通用功能，让开发者可以在其上进行定制开发，而无需从零开始编写所有代码。框架通常具有以下特点：

1. 抽象和封装：框架通过封装底层的复杂性，提供了一组简单易用的 API，隐藏了底层技术细节，使开发者能够更专注于业务逻辑的实现。

2. 设计模式和约定：框架通常基于一些设计模式和最佳实践，定义了一套规范和约定，帮助开发者编写结构清晰、可维护的代码。

3. 提供通用功能：框架通常提供了一些通用功能和组件，如路由、中间件、数据库访问、模板引擎等，这些功能可以被开发者直接使用，减少了重复劳动。

4. 可扩展性和定制性：框架通常允许开发者根据自己的需求进行扩展和定制，通过插件、扩展机制或配置文件，使开发者能够灵活地适应不同的场景。

对于 Express 框架来说，它是基于 Node.js 平台的一个 Web 应用程序开发框架。它提供了一套简洁而灵活的工具和功能，帮助开发者更轻松地构建 Web 应用程序和 API。Express 框架定义了一些常用的路由、中间件和视图渲染等功能，使得开发者可以更快速地搭建 Web 应用程序的基础结构，并专注于业务逻辑的实现。

框架的作用在于提供了一种开发方式和结构，减少了开发过程中的重复工作，提高了开发效率，同时也帮助维护代码的一致性和可维护性。开发者可以通过使用框架，快速构建应用程序，并且可以借助框架的规范和工具来解决常见的开发问题，从而加快开发进程并提高代码质量。



## Express框架

Express 是一个基于 Node.js 的 Web 应用程序框架，它提供了一组简洁而灵活的工具和功能，用于开发 Web 应用程序和 API。

Express 框架的主要作用包括：

1. 简化了 Node.js Web 应用程序的开发：Express 提供了简洁而直观的 API，使得创建和处理 HTTP 请求变得更加容易。它抽象了底层的 HTTP 功能，提供了路由、中间件、请求处理、视图渲染等功能，让开发者能够更专注于业务逻辑的实现，而不用过多关注底层细节。

2. 提供了灵活的路由和中间件系统：Express 具有强大的路由功能，可以根据 URL 和 HTTP 方法将请求映射到特定的处理程序函数。通过定义路由规则，可以实现 URL 路径与处理程序之间的映射关系。此外，Express 还支持中间件，允许你在请求到达处理程序之前或之后执行一些额外的逻辑，例如身份验证、日志记录、错误处理等。

3. 支持模板引擎：Express 可以与各种模板引擎（如 EJS、Pug、Handlebars 等）无缝集成，使得在服务器端渲染动态页面变得更加简单。模板引擎可以帮助你生成 HTML 页面，并与数据进行动态交互，从而实现更丰富的用户界面。

4. 可扩展性和丰富的插件生态系统：Express 框架非常灵活，允许你根据项目需求进行定制和扩展。此外，它拥有庞大的插件生态系统，你可以根据需要选择和使用各种第三方插件来增强 Express 的功能，例如身份验证、数据库连接、会话管理等。

总结来说，Express 并不是一个工具库，而是一个 Web 应用程序开发框架。它提供了一组强大的工具和功能，帮助开发者更高效地构建基于 Node.js 的 Web 应用程序，并且具有良好的可扩展性和丰富的生态系统。



## 路由规则

>
>
>路由规则（Routing Rules）是指在 Web 应用程序中定义 URL 路径与相应处理程序之间的映射关系的规则。
>
>在一个 Web 应用程序中，客户端通过 URL 访问不同的页面或资源，而路由规则就是用来确定当某个特定的 URL 请求到达服务器时，应该由哪个处理程序来处理这个请求。
>
>路由规则通常由两部分组成：URL 路径和处理程序。
>
>URL 路径是指客户端发起的请求的 URL，例如 `/home`、`/users` 等。处理程序是指服务器上用来处理请求的代码或函数，它可以执行一系列操作，如查询数据库、生成响应等。
>
>通过定义路由规则，Web 应用程序能够根据不同的 URL 请求将其分发给相应的处理程序，从而实现不同页面或资源的访问和处理。
>
>例如，假设有一个 Web 应用程序，其中有以下两个路由规则：
>
>1. 路由规则：`/home`
>   处理程序：显示主页内容
>
>2. 路由规则：`/users`
>   处理程序：查询数据库并返回用户列表
>
>当客户端请求 `/home` 路径时，服务器将根据路由规则找到与之对应的处理程序，并执行该处理程序来显示主页内容。同样地，当客户端请求 `/users` 路径时，服务器将找到对应的处理程序，并执行该处理程序来查询数据库并返回用户列表。
>
>通过定义合适的路由规则，可以实现不同 URL 请求的分发和处理，使 Web 应用程序能够提供不同页面和功能。



路由是指当根据用户的操作响应对应的反馈

>是的，路由是指根据用户的请求路径和请求方法，将请求导向不同的处理程序或逻辑的过程。
>
>当用户在浏览器中输入 URL 或通过其他方式发送请求时，请求中包含了请求路径和请求方法。路由的作用就是根据这些请求的信息，将请求导向不同的处理程序或逻辑，以返回相应的结果给用户。
>
>例如，当用户访问网站的根路径 `'/'` 时，你可以定义一个路由规则来处理该路径的 GET 请求，并返回一个欢迎页面。当用户访问一个特定的商品页面，你可以定义另一个路由规则来处理该路径的 GET 请求，并从数据库中获取该商品的信息并渲染页面。这样，不同的路径和请求方法将导致服务器调用不同的处理程序或逻辑，以返回相应的内容给用户。
>
>路由是将用户的请求与后端应用程序的不同功能模块相匹配的机制。通过定义不同的路由规则，你可以根据用户的操作提供不同的反馈和功能。这样可以使应用程序具备更丰富和灵活的功能，满足不同用户的需求。

**路由相当于一个指向，将请求指向不同的方向?**

>是的，你可以将路由视为将用户的请求指向不同的方向或路径。
>
>当用户发送请求时，请求中包含了请求路径和请求方法。路由的作用就是根据这些请求的信息，将请求导向不同的处理程序、控制器或逻辑代码，以执行相应的操作。
>
>路由将请求的路径和方法与相应的处理程序或控制器关联起来。它指示服务器在接收到特定请求时应该执行哪些代码逻辑，并返回相应的结果给用户。这可以包括渲染页面、处理表单数据、调用其他服务或资源等操作。
>
>通过定义不同的路由规则，你可以为不同的请求路径和方法设置不同的处理逻辑，从而实现应用程序的不同功能和行为。这种机制使得服务器能够根据用户的请求动态地确定要执行的操作，以提供适当的响应和功能。
>
>因此，路由起到了将用户的请求导向不同方向或路径的作用，使得服务器能够根据请求的不同进行相应的处理和反馈。





## 304 Not Modified

>
>
>当客户端发送请求并在服务器上进行了缓存的情况下，服务器可能会返回状态码 "304 Not Modified"。这意味着客户端的缓存副本仍然有效，服务器没有返回新的数据，而是建议客户端使用其缓存的副本。
>
>当客户端发送带有缓存验证信息的请求时，如请求头中的 If-Modified-Since 或 If-None-Match 字段，服务器会使用这些信息来判断客户端的缓存是否过期。如果服务器确定客户端的缓存仍然有效，则返回状态码 "304 Not Modified"，告知客户端使用缓存副本。
>
>这种机制可以减少网络流量和服务器负载，因为客户端可以使用其缓存的副本而无需从服务器获取新的数据。只有当缓存副本过期或被认为无效时，客户端才会收到服务器返回的实际数据（状态码200）。
>
>当客户端收到 "304 Not Modified" 响应时，它可以继续使用缓存的数据，而无需再次下载完整的响应内容。这可以提高页面加载速度和减少网络流量。
>
>需要注意的是，服务器返回 "304 Not Modified" 仅表示客户端的缓存仍然有效，并没有返回实际的数据内容。客户端仍然使用其缓存的副本。
>
>



就是说如果服务器响应内容一致，由于第一访问已加载，所以后续无需重复加载的意思

>
>
>是的，你理解得很准确。
>
>当客户端第一次请求某个资源时，服务器会返回完整的响应内容，并在响应头中包含缓存相关的信息，如缓存过期时间（Expires 或 Cache-Control）和实体标签（ETag）。客户端接收到响应后会将该资源缓存起来。
>
>在后续的请求中，如果客户端需要再次获取相同的资源，它会发送一个带有缓存验证信息的请求头（如 If-Modified-Since 或 If-None-Match）给服务器。这些验证信息是根据之前缓存的响应生成的。
>
>服务器收到带有缓存验证信息的请求后，会对验证信息进行比较，判断客户端的缓存是否仍然有效。如果服务器判断客户端的缓存仍然有效（即资源没有变化），它会返回状态码 "304 Not Modified"，告诉客户端继续使用缓存的副本，无需重复下载完整的响应内容。
>
>这样的机制可以减少网络流量和提高页面加载速度，因为客户端可以重复使用缓存的资源，只有当资源发生变化时才需要重新下载。
>
>需要注意的是，服务器可以通过不同的方式设置缓存策略，例如设置缓存过期时间、启用缓存验证等。客户端在发送请求时会根据这些缓存策略进行相应的处理，以提高性能和效率。



## xhr是ajax

>
>
>是的，XHR（XMLHttpRequest）是一种用于进行异步通信的技术，而 Ajax（Asynchronous JavaScript and XML）则是一种利用异步通信进行网页开发的方法。XHR 是实现 Ajax 的核心技术之一。
>
>Ajax 使用 XHR 对象来在后台与服务器进行数据交换，实现页面的部分更新和动态加载内容，而无需刷新整个页面。XHR 对象允许通过 JavaScript 发送 HTTP 请求（如 GET、POST），并处理服务器响应。
>
>XHR 最初设计用于发送和接收 XML 数据，因此得名 XMLHttpRequest。然而，随着时间的推移，XHR 已经扩展支持其他数据格式，如 JSON、HTML、纯文本等，使其成为与服务器进行异步通信的通用工具。
>
>因此，XHR 是实现 Ajax 的基础，可以说XHR是Ajax的一部分。



### XMLHttpRequest (XHR) 是一个内置的 JavaScript 对象

是的，XMLHttpRequest (XHR) 是一个内置的 JavaScript 对象，用于在浏览器中与服务器进行异步通信。它提供了一种简单和灵活的方式来发送 HTTP 请求和处理服务器响应，实现前端与后端的数据交互。

通过创建 XMLHttpRequest 对象，你可以设置请求的方法、URL、请求头、请求体等信息，并发送请求到服务器。一旦服务器响应返回，你可以通过监听 XMLHttpRequest 对象的事件来获取响应的数据，并对其进行处理。

XHR 对象的常用方法包括 `open()` 用于初始化一个请求，`send()` 用于发送请求，`abort()` 用于中断请求。XHR 对象的常用事件包括 `readystatechange` 用于监听状态的变化，`load` 用于监听请求完成，`error` 用于监听请求错误等。

通过 XMLHttpRequest 对象，可以实现异步加载数据、动态更新页面内容、与服务器进行数据交换等功能，使得前端与后端之间的通信更加灵活和高效。





0 - 未初始化  		1 - open方法调用完毕  		2 - send方法调用完毕  		3 - 服务端返回了部分结果  		4 - 服务端返回了所有结果



## XHRduixaing - onreadystatechange的五个状态

>
>
>在 XMLHttpRequest 对象中，`onreadystatechange` 事件会在请求状态发生变化时触发。这个事件会根据请求的不同阶段，触发不同的状态码。
>
>以下是 `onreadystatechange` 事件的5 个状态码及其含义：
>
>0: 请求未初始化（`UNSENT`）
>在调用 `open()` 方法之前，请求的状态是未初始化的。此时 `XMLHttpRequest` 对象已经创建，但尚未调用 `open()` 方法。
>
>1: 服务器连接已建立（`OPENED`）
>在调用 `open()` 方法之后，请求的状态是服务器连接已建立。此时 `XMLHttpRequest` 对象的 `open()` 方法已被调用，但尚未调用 `send()` 方法。
>
>2: 请求已接收（`HEADERS_RECEIVED`）
>在调用 `send()` 方法之后，请求的状态是请求已接收。此时已经接收到服务器的响应头信息，但尚未接收到响应体。
>
>3: 请求处理中（`LOADING`）
>在接收到响应头信息之后，请求的状态是请求处理中。此时正在接收服务器返回的响应体数据。可以通过 `responseText` 或 `responseXML` 属性获取响应数据的部分内容。
>
>4: 请求已完成且响应就绪（`DONE`）
>在请求完成并且响应就绪时，请求的状态是已完成且响应就绪。此时已经完全接收到服务器返回的响应数据。可以通过 `responseText` 或 `responseXML` 属性获取完整的响应数据。
>
>通过监听 `onreadystatechange`  事件，并根据不同的状态码进行逻辑处理，你可以在 Ajax 请求的不同阶段执行相应的操作，如更新页面内容或处理服务器返回的数据。



## ajax传递参数的位置（视频学习）

在地址栏进行传递参数

<img src="Ajax学习笔记.assets/image-20230609170939610.png" alt="image-20230609170939610" style="zoom:50%;" />

<img src="Ajax学习笔记.assets/image-20230609171048875.png" alt="image-20230609171048875" style="zoom:67%;" />





# 6.10 下午三点

## 后台服务器响应

js 后台服务器的响应： 需要进行重新启动端口，才能更新响应前端的数据



## 后台服务器中 res.send(str)

>在某些情况下，后台服务器的 `res.send()` 方法可能只能发送字符串形式的内容。这取决于后台服务器框架或库的实现。
>
>一些后台服务器框架或库提供了特定的方法来发送非字符串形式的内容，例如：
>
>- 对于 JSON 数据，可以使用 `res.json()` 方法来发送 JSON 格式的响应。
>- 对于文件，可以使用 `res.sendFile()` 方法来发送文件。
>- 对于二进制数据，可以使用 `res.send()` 方法发送 Buffer 对象。
>
>如果需要发送非字符串形式的内容，可以查看后台服务器框架或库的文档，了解相应的发送方法。另外，也可以将非字符串内容转换为字符串后再发送。



## 后台服务器 需要/ 不需要 重新启动服务器端口返回 修改后的响应

如果在前端访问后台服务器获取数据时，发现后台服务器的响应没有及时更新前端的数据，可能有几个原因导致这种情况发生：

1. 缓存：浏览器会对请求的响应进行缓存，如果响应被缓存了，浏览器会直接从缓存中获取响应数据而不是发送请求到服务器。可以在后台服务器的响应中设置相应的响应头，禁用缓存或者设置合适的缓存策略。

2. 前端代码逻辑：前端代码可能有自己的逻辑，可能会将响应数据缓存到本地，或者使用了旧的数据进行渲染。确保前端代码逻辑正确，没有将旧的数据持久化或缓存。

3. 后台服务器缓存：后台服务器也可能对数据进行了缓存，如果后台服务器缓存了旧的数据，即使数据在后台发生了更新，前端仍然获取到的是旧的数据。在后台服务器中可以检查缓存机制，确保在数据更新后及时刷新缓存。

如果在后台服务器的代码中对响应进行了更新，但前端仍然无法获取到最新的数据，可以尝试以下方法：

- 确保后台服务器的代码已经正确地处理了更新数据的逻辑，并且重新启动了服务器，以确保最新的代码生效。
- 清除浏览器缓存，可以通过按下 Ctrl + Shift + R（或者 Cmd + Shift + R）强制刷新页面，并清除浏览器缓存。
- 使用开发者工具查看网络请求和响应，确保响应数据确实已经更新，并且在前端代码中正确处理了响应数据的更新。





## 后台的端口启动后，能实时更改响应体的内容吗？

当后端的端口启动后，它会一直监听该端口上的请求，并根据请求生成相应的响应体。在端口启动后，可以通过修改后端代码中的逻辑来改变响应体的内容。

如果你在后端代码中修改了响应体的内容，并保存了修改后的代码，那么在后续的请求中，后端会根据新的代码逻辑生成新的响应体，从而实现实时更改响应体的内容。

需要注意的是，如果后端代码中的改动涉及到了缓存或其他类似的机制，可能需要手动刷新或清除缓存才能获取到最新的响应体内容。另外，**有些服务器框架可能需要重启服务器才能应用代码的改动。**

总结起来，后端的端口启动后，可以实时更改响应体的内容，但需要注意缓存和服务器框架的特性对实时更新的影响。





## 服务器框架可以实时更改响应体内容（在端口启动的同时）

>
>
>对于某些服务器框架，它们可能提供了一些特定的方法或机制来实现实时更改响应体内容。以下是一些常见的方法或技术，可以帮助实现实时更新响应体内容：
>
>1. 热重载（Hot Reload）：某些服务器框架支持热重载，它可以在代码发生改动时自动重新加载代码，从而使修改的内容立即生效，包括响应体内容。常见的热重载工具包括 nodemon、pm2 等。
>
>2. 模板引擎：如果你在后端使用了模板引擎来生成响应体内容，可以通过修改模板文件来实现实时更改。一些模板引擎（如Pug、EJS）在开发模式下可以自动监测文件变化并重新渲染模板。
>
>3. 实时数据推送：对于需要实时更新数据的应用，可以采用实时数据推送的方式，如使用 WebSocket 或类似的技术来实现服务器向客户端推送数据更新。这样可以实现实时更新响应体内容而无需刷新整个页面。
>
>需要根据具体的服务器框架和应用场景来确定使用哪种方法。建议查阅相关服务器框架的文档或社区资源，了解它们提供的实时更新机制和相应的使用方法。





### 安装nodemon 工具， 实现自动保存， 端口实时更新数据

**npm install -g nodemon**

>`npm install -g nodemon` 是一个使用 npm 包管理器全局安装 nodemon 工具的命令。
>
>nodemon 是一个用于开发环境的工具，它可以监视你的代码文件的变化，并在文件发生变化时自动重新启动 Node.js 服务器。这样你在开发过程中不需要手动重启服务器，而是由 nodemon 自动帮你处理。
>
>通过全局安装 nodemon，你可以在命令行中直接使用 `nodemon` 命令来启动你的 Node.js 项目。例如，如果你的项目入口文件是 `app.js`，你可以在命令行中运行 `nodemon app.js` 来启动服务器。当你修改了代码并保存后，nodemon 会自动检测到文件变化并重新启动服务器，以便你能够立即看到代码的更改效果，提高开发效率。
>
>这对于开发过程中频繁修改代码并进行调试非常方便，可以避免手动重启服务器的繁琐操作。注意，nodemon 只用于开发环境，不应在生产环境中使用。
>
>通过使用 nodemon，你可以实现代码的热重载，使得你在开发过程中的修改能够即时生效，提高开发效率。



#### 如果出现在此系统上禁止运行脚本

>
>
>这个错误提示是由于 PowerShell 的执行策略限制导致的。默认情况下，PowerShell 的执行策略是 Restricted（受限制），它会禁止运行脚本文件。
>
>要解决这个问题，你可以尝试以下两种方法之一：
>
>1. 打开一个以管理员身份运行的 PowerShell 窗口，并执行以下命令来更改执行策略为 RemoteSigned（远程签名）：
>   ```
>   Set-ExecutionPolicy RemoteSigned
>   ```
>
>2. 打开一个以管理员身份运行的 PowerShell 窗口，并执行以下命令来临时解除执行策略限制：
>   ```
>   Set-ExecutionPolicy Bypass
>   ```
>
>请注意，这些方法可能需要管理员权限，且可能会对系统安全性产生一定影响。建议在开发环境中使用，生产环境中应谨慎处理执行策略。
>
>如果你仍然遇到问题，请参考错误提示中提供的链接，查看关于 PowerShell 执行策略的更多信息和解决方案。



#### 为什么加前缀 npx后可以解决这个问题

>
>
>当你使用 `npx` 命令来运行 `nodemon` 时，它会帮助你解决 PowerShell 执行策略的限制问题。
>
>`npx` 是一个用于执行 npm 包的工具，它会在运行时临时安装并执行指定的包。通过使用 `npx` 命令来运行 `nodemon`，它会创建一个临时的执行环境，绕过 PowerShell 的执行策略限制。
>
>因此，当你使用 `npx nodemon` 来运行 `nodemon` 时，即使 PowerShell 的执行策略设置为 Restricted（受限制），你仍然可以成功运行 `nodemon`，而不会遇到执行策略限制的错误。
>
>总结起来，使用 `npx nodemon` 可以绕过 PowerShell 执行策略的限制，让你能够顺利运行 `nodemon`。

#### nodemon执行脚本会提醒，那为什么node.js不会提醒

>当你使用 `node` 命令执行脚本时，它不会触发执行策略限制的提示，**是因为 `node` 是一个已知的可信执行环境**，并且在大多数系统上已被广泛使用。
>
>相反，`nodemon` 是一个第三方工具，它可能没有得到系统的认可，因此执行策略可能会拒绝执行它。这是为了防止未经授权的脚本执行。
>
>通过使用 `npx nodemon` 命令，你可以通过 `npx` 工具以临时方式执行 `nodemon`，而不需要更改系统的执行策略设置。`npx` 会在每次执行时下载并执行 `nodemon`，因此它不需要在本地全局安装 `nodemon`。
>
>请注意，使用 `npx` 临时执行 `nodemon` 时，系统仍会对 `nodemon` 的执行进行验证，并可能显示一些安全提示。你应该确保从可信源获取 `nodemon`，并仔细阅读和理解任何安全警告，以确保你的系统的安全性。
>
>



## 解决缓存机制，是对请求加一个时间戳或者随机数

IE请求， 存在着浏览器缓存， 如果服务器更新了数据，重复请求时ie缓存，会默认识别为第一次请求返回的数据，所以需要让每次请求差异化，可选择加 **时间戳** 或者 **随机数** 

这样做会在 URL 中添加一个随机的时间戳，以确保每次请求的 URL 都是不同的，从而绕过浏览器的缓存机制。这样可以确保每次请求都是最新的内容，而不是从缓存中获取旧的数据。

### 验证码请求同理



>是的，验证码的图片也可能存在缓存。为了确保每次请求获取到的是最新的验证码图片，可以在点击事件中给验证码图片的 URL 添加一个随机数或时间戳参数，以绕过缓存机制。
>
>例如，你可以将验证码图片的 URL 修改为类似以下的形式：
>
>```javascript
>var captchaImg = document.getElementById("captcha-img");
>captchaImg.src = "http://example.com/captcha?timestamp=" + Date.now();
>```
>
>这样每次点击事件触发时，都会生成一个新的 URL，浏览器会认为这是一个新的请求，从而获取到最新的验证码图片。
>
>注意，具体的验证码生成和验证逻辑需要根据你的实际情况进行实现。这里只是简单示范了如何在点击事件中添加时间戳来绕过缓存获取最新的验证码图片。

通过这种方式， 浏览器会将这些请求识别为不同请求，每次获取都为最新的验证码图片



## ajax请求超时与网络异常

>
>
>在 Ajax 请求中，可能会遇到两种情况：请求超时和网络异常。
>
>1. 请求超时：当发送 Ajax 请求后，如果服务器在一定时间内没有响应，就会触发请求超时。这通常由以下原因引起：
>   - 服务器负载过高或处理时间过长。
>   - 网络连接不稳定或延迟高。
>   - 请求的数据量过大。
>
>   为了处理请求超时，可以使用 Ajax 提供的超时设置。例如，在 XMLHttpRequest 对象上设置 `timeout` 属性，指定请求的最大等待时间（以毫秒为单位）。当超过指定时间后，将触发 `ontimeout` 事件，你可以在事件处理函数中进行相应的处理，例如重新发送请求或显示错误提示。
>
>2. 网络异常：在发送 Ajax 请求时，可能会遇到网络异常，如网络连接中断、服务器不可达等。这些异常通常会触发 `onerror` 事件或导致请求失败。
>
>   处理网络异常的方法可以包括：
>   - 在 `onerror` 事件处理函数中，根据具体情况进行错误处理，例如显示错误信息。
>   - 检查网络连接状态，确保网络连接正常。
>   - 提供合适的错误反馈给用户，帮助他们了解发生了什么问题。
>
>请注意，请求超时和网络异常的处理方法可能因编程语言、框架或具体情况而异。在实际开发中，根据你使用的技术栈选择相应的处理方式。



## res.setHeader('Access-Control-Allow-Headers', '*');

##  res.setHeader('Access-Control-Allow-Origin', '*')

>
>
>这两句代码是在服务器端设置响应头，用于处理跨域请求。让我们来详细解释一下它们的作用：
>
>1. `res.setHeader('Access-Control-Allow-Origin', '*');`
>
>   这行代码设置了响应头中的 "Access-Control-Allow-Origin" 字段，它的值为 "*"。这个字段指定了响应的资源可以被哪些来源（域名）访问。通过将值设置为 "*"，表示允许来自任意域名的请求访问服务器的资源。如果你想限制只有特定的域名可以访问，可以将 "*" 替换为允许访问的域名。
>
>2. `res.setHeader('Access-Control-Allow-Headers', '*');`
>
>   这行代码设置了响应头中的 "Access-Control-Allow-Headers" 字段，它的值为 "*"。这个字段指定了允许的请求头列表，即客户端可以在请求中携带哪些自定义的请求头。通过将值设置为 "*"，表示允许客户端携带任意自定义的请求头。如果你想限制只允许特定的请求头，可以将 "*" 替换为允许的请求头列表，多个请求头使用逗号分隔。
>
>这两行代码的作用是解决跨域请求的限制。默认情况下，浏览器会根据 限制跨域请求，即只有在相同域名、端口和协议下的请求才会被允许。而设置 "Access-Control-Allow-Origin" 字段为 "*" 则表示允许来自任意域名的请求访问资源，设置 "Access-Control-Allow-Headers" 字段为 "*" 则表示允许客户端携带任意自定义的请求头。
>
>需要注意的是，在生产环境中，不建议将 "Access-Control-Allow-Origin" 字段设置为 "*"，这样会允许来自任意域名的请求访问资源，存在安全风险。应该根据实际需求，仅允许特定的域名或一组受信任的域名进行访问。



## 防抖和节流 优化技术

防抖（Debouncing）和节流（Throttling）是两种常用的优化技术，用于控制函数的执行频率。

1. 防抖：
   防抖的目标是确保在一定时间内只执行一次函数。当连续触发同一个事件时，只有在等待时间间隔超过指定时间后才执行函数，如果在等待时间内再次触发了该事件，则重新计时。
   
   防抖的常见应用场景包括：**输入框输入内容后触发搜索，窗口调整大小后触发事件**等。

   实现防抖的方式可以是使用定时器和事件监听。当触发事件时，先清除之前的定时器，再设置一个新的定时器，等待指定时间后执行函数。

2. 节流：
   节流的目标是控制函数的执行频率，确保函数在一定时间内最多执行一次。当连续触发同一个事件时，只有在指定的时间间隔过去后才执行函数，如果在时间间隔内再次触发了该事件，则忽略该次触发。

   节流的常见应用场景包括：**页面滚动时触发加载更多，按钮点击时防止多次提交**等。

   实现节流的方式可以是使用定时器和事件监听。当触发事件时，判断是否在指定时间间隔内已经执行了函数，如果是，则忽略该次触发，如果不是，则执行函数并设置一个新的定时器，在指定时间间隔后才能再次触发。

防抖和节流都是为了优化性能和提升用户体验，避免过多的函数执行或事件触发。选择使用哪种技术取决于具体的需求和场景。在实际开发中，可以根据需要选择适合的方式来实现防抖和节流。



### 防抖作用 详

>防抖函数的作用是延迟函数的执行，在连续触发事件时，只有在一定的等待时间后才会执行函数。
>
>当一个事件被频繁触发时，比如按钮点击、输入框输入等，如果每次事件触发都立即执行函数，可能会导致不必要的计算或操作，甚至影响用户体验。防抖函数可以解决这个问题，它会在事件触发后设定一个等待时间，如果在等待时间内再次触发事件，会重新计时等待时间，直到等待时间结束且没有新的触发事件时才执行函数。
>
>防抖函数的主要作用包括：
>
>1. 减少函数执行的次数，避免不必要的计算和操作。
>2. 防止因连续触发事件导致的意外行为，比如按钮连续点击导致重复提交表单。
>3. 提升用户体验，确保在一定的等待时间内只执行一次函数，避免频繁触发导致的页面闪烁或不稳定的感觉。
>
>防抖函数的实现方式一般使用定时器，当事件触发时，会清除之前的定时器并设立一个新的定时器，等待一定的时间后执行函数。如果在等待时间内再次触发事件，会重新计时等待时间。这样可以确保函数的执行被延迟，直到一定的静默期过去后才执行。
>
>总结而言，防抖函数是一种优化工具，用于限制函数的执行频率，避免连续触发事件导致的性能问题和不必要的操作。它可以提升页面的响应速度和用户体验，确保函数在一定的静默期后执行。

### 节流作用 详

>
>
>节流函数的作用是限制函数的执行频率，确保在指定的时间间隔内只执行一次函数。
>
>当一个事件被频繁触发时，比如滚动条滚动、窗口调整大小或者鼠标移动，如果每次事件触发都执行函数，可能会导致性能问题或不必要的操作。节流函数可以解决这个问题，它会根据设定的时间间隔，在该间隔内只执行一次函数，并忽略接下来的事件触发，直到时间间隔过去后再次执行。
>
>使用节流函数的好处包括：
>
>1. 减少函数执行的次数，降低对系统资源的占用。
>2. 提升页面的响应速度和性能，减少不必要的计算和操作。
>3. 避免因频繁触发事件而导致的意外行为，比如误操作或不一致的状态。
>
>常见的节流函数实现方式包括使用定时器和时间戳两种方法。在定时器方式中，函数的执行会被延迟一段时间，而在时间戳方式中，函数的执行会在固定的时间间隔内执行。具体选择哪种方式取决于具体的需求和场景。
>
>总而言之，节流函数是一种优化工具，可以控制函数的执行频率，避免频繁触发而导致的性能问题，提升用户体验。



### 防抖和节流之间的区别

>
>
>是的，防抖和节流在实现上有一些区别，尽管它们的目标都是控制函数的执行频率。
>
>主要区别如下：
>
>1. **触发时机：**防抖在事件触发后等待一段时间后执行函数，而节流在一定时间间隔内最多执行一次函数。
>
>2. **函数执行时机：**防抖在等待时间内再次触发事件会重新计时，而节流在时间间隔内再次触发事件会被忽略。
>
>3. **执行次数：**防抖在等待时间内如果触发了多次事件，只有最后一次事件会执行函数，而节流在时间间隔内只会执行一次函数。
>
>4. **用户体验：**防抖能够确保在用户停止触发事件一段时间后才执行函数，常用于输入框输入内容后触发搜索等场景，可以避免频繁的请求或操作。节流能够控制函数的执行频率，确保在一定时间内最多执行一次函数，常用于页面滚动加载、按钮点击防止重复提交等场景。
>
>总结来说，防抖是为了在一定时间内只执行最后一次触发的函数，节流是为了在一定时间间隔内最多执行一次函数。选择使用防抖还是节流取决于具体的需求和场景。
>
>
>
>防抖函数的作用是避免在短时间内频繁触发事件导致过多的计算或请求，通过控制事件执行的频率来提升性能和用户体验



## JSON.parse()和JSON.stringify()

>
>
>`JSON.parse()` 和 `JSON.stringify()` 是 JavaScript 中用于处理 JSON 数据的方法。
>
>- `JSON.parse()` 方法用于将 JSON 字符串转换为 JavaScript 对象或其他原始数据类型。它接受一个 JSON 字符串作为参数，并返回相应的 JavaScript 对象或值。
>
>  示例代码：
>  ```javascript
>  var jsonString = '{"name":"John","age":30,"city":"New York"}';
>  var obj = JSON.parse(jsonString);
>  console.log(obj); // 输出 { name: 'John', age: 30, city: 'New York' }
>  ```
>
>- `JSON.stringify()` 方法用于将 JavaScript 对象或值转换为 JSON 字符串。它接受一个 JavaScript 对象或值作为参数，并返回相应的 JSON 字符串。
>
>  示例代码：
>  ```javascript
>  var obj = { name: 'John', age: 30, city: 'New York' };
>  var jsonString = JSON.stringify(obj);
>  console.log(jsonString); // 输出 '{"name":"John","age":30,"city":"New York"}'
>  ```
>
>需要注意的是，`JSON.parse()` 只能将合法的 JSON 字符串转换为 JavaScript 对象，否则会抛出异常。而 `JSON.stringify()` 可以处理包括对象、数组、字符串、数字、布尔值和 null 在内的大多数 JavaScript 值，并将它们转换为相应的 JSON 字符串。
>
>这两个方法常用于在客户端和服务器之间传递数据时进行 JSON 格式的转换。



## Jquery通用方法发送 自定义 ajax请求

>
>
>通用 AJAX 请求并不一定是 POST 请求，它可以是任何请求方法，如 GET、POST、PUT、DELETE 等，具体取决于你的需求和后端接口的定义。
>
>通常情况下，GET 请求用于获取数据，POST 请求用于提交数据，PUT 请求用于更新数据，DELETE 请求用于删除数据。但这只是一种常见的约定，并不是绝对的规定。
>
>在 AJAX 中，使用 `$.ajax()` 方法可以发送各种类型的请求，通过指定 `type` 参数来定义请求的方法。例如：
>
>```javascript
>$.ajax({
>  url: 'http://example.com/api/data',
>  type: 'GET', // 或 'POST', 'PUT', 'DELETE' 等
>  data: { key1: 'value1', key2: 'value2' },
>  success: function(response) {
>    // 处理成功响应
>  },
>  error: function(xhr, status, error) {
>    // 处理错误响应
>  }
>});
>```
>
>通过指定 `type` 参数为不同的请求方法，你可以发送对应的请求。同时，可以通过 `data` 参数来传递请求的数据。
>
>需要注意的是，通用 AJAX 请求并不限定为 POST 请求，而是根据实际需求来选择合适的请求方法。



## Get 和 Post 应用场景

>
>
>GET 和 POST 是 HTTP 请求方法，用于向服务器请求或提交数据，它们在使用场景和特点上有一些区别。
>
>GET 请求：
>- 用于从服务器获取数据，获取资源。可以通过 URL 的查询参数传递少量数据。
>- 请求的数据会附加在 URL 的查询参数中，以键值对的形式传递给服务器。例如：`https://example.com/api?param1=value1&param2=value2`
>- GET 请求**可以被缓存**，可以通过浏览器地址栏直接访问。
>- GET 请求在浏览器历史记录中留下记录。
>- GET 请求对数据长度有限制，通常被限制在 URL 长度的最大值。
>
>POST 请求：
>- 用于向服务器提交数据，发送资源。适合提交大量数据或包含敏感信息的情况。
>- 请求的数据会作为请求的主体发送给服务器，而不是附加在 URL 中。
>- POST 请求不会被缓存，不可以通过浏览器地址栏直接访问。
>- POST 请求不会在浏览器历史记录中留下记录。
>- POST 请求对数据长度没有固定限制。
>
>根据以上特点，一般来说，GET 请求**适合用于获取数据**，例如获取页面内容、查询数据等，而 POST **请求适合用于提交数据，例如提交表单、创建资源等**。GET 请求将参数暴露在 URL 中，适合传递少量非敏感数据，而 POST 请求将参数放在请求的主体中，适合传递大量数据或包含敏感信息的情况。
>
>需要根据具体的业务需求和安全考虑，选择合适的请求方法。在实际开发中，常常会根据操作的性质和数据的大小选择使用 GET 或 POST 请求，以达到更好的效果和安全性。



### 请求主体

>
>
>请求的主体是 HTTP 请求中的一部分，用于传输请求的数据。主要用于 POST、PUT 等需要传递数据的请求方法。
>
>在 HTTP 请求中，请求的主体位于请求头部之后，格式为：
>
>```
><请求方法> <请求路径> HTTP/<协议版本>
><请求头部1>
><请求头部2>
>...
><空行>
><请求主体>
>```
>
>请求主体可以包含各种类型的数据，如表单数据、JSON 数据、文件等。具体的数据格式和编码方式取决于应用程序的需求和约定。
>
>对于 GET 请求，请求的参数通常是通过查询字符串的形式放在 URL 中，而不需要请求主体。
>
>对于 POST 请求，数据通常放在请求主体中进行传递，可以使用不同的数据格式，如表单数据、JSON 数据等。例如，通过表单提交的 POST 请求会将表单字段及其值放在请求主体中。
>
>总而言之，请求主体是用于传输请求数据的部分，可以包含各种类型的数据，取决于请求的目的和约定。



### 请求头

>
>
>请求头的内容由HTTP协议规定，并且在实际开发中可以根据需求进行自定义。以下是一些常见的请求头字段及其示例：
>
>1. User-Agent：用于标识发送请求的客户端类型和版本。
>   示例：User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36
>
>2. Accept：用于指定客户端能够接受的内容类型。
>   示例：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
>
>3. Content-Type：用于指定请求体的数据类型。
>   示例：Content-Type: application/json
>
>4. Authorization：用于发送身份验证凭据，如基本认证或 Bearer 令牌。
>   示例：Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
>
>5. Cookie：用于发送存储在客户端的会话标识符。
>   示例：Cookie: sessionId=abc123; username=johndoe
>
>这些示例只是一小部分常见的请求头字段，实际上还有很多其他的请求头字段，可以根据具体需求进行使用和定义。



### 请求头的作用：

请求头不仅仅是一种限制，它还承载了很多功能和信息。请求头的主要作用如下：

1. 传递请求的元数据：请求头可以包含各种元数据信息，如请求的来源、用户代理、支持的内容类型等，这些信息帮助服务器理解和处理请求。

2. 控制缓存和验证：请求头中的一些字段（如Cache-Control、ETag等）可以用于控制缓存机制，实现缓存的有效利用和验证。

3. 身份验证和授权：请求头中的一些字段（如Authorization）用于发送身份验证凭据，进行用户身份验证和授权。

4. 指定期望的响应内容类型：请求头中的Accept字段可以指定客户端期望接收的响应内容类型，帮助服务器返回合适的响应数据。

5. 传递请求体的数据类型和编码：请求头中的Content-Type字段用于指定请求体中数据的类型和编码方式，帮助服务器正确解析请求体的数据。

6. 定义自定义的请求头字段：开发者可以自定义请求头字段，根据具体需求传递特定的信息给服务器。

因此，请求头不仅仅是一种限制，它承载了多种功能和信息，用于在客户端和服务器之间传递额外的数据和约定。它可以帮助实现更精确的请求和响应处理，提升通信的效率和安全性。



## Jquery



jQuery是一个JavaScript库。它被设计用于简化JavaScript编程，提供了许多方便的功能和方法，使开发者能够更轻松地操作HTML文档、处理事件、执行动画效果、发送Ajax请求等。

jQuery库的主要目标是使JavaScript代码编写更简洁、更具可读性，并提供跨浏览器兼容性。它封装了一系列常用的DOM操作方法和功能，使开发者可以使用简洁的语法来处理复杂的操作。

通过引入jQuery库，开发者可以使用其提供的函数和方法，快速地实现常见的网页交互效果和功能，无需自己编写复杂的JavaScript代码。由于其广泛的应用和强大的功能，jQuery在Web开发中得到了广泛的应用，并成为最受欢迎的JavaScript库之一。



## axios

>
>
>Axios是一个基于Promise的HTTP客户端库，用于发送HTTP请求。它可以在浏览器和Node.js环境中使用，并提供了简洁而强大的API，使得发送和处理HTTP请求变得更加方便。
>
>Axios的主要特点包括：
>1. 支持Promise API：Axios基于Promise，可以轻松地处理异步操作和回调。
>2. 支持浏览器和Node.js：Axios可以在浏览器和Node.js环境中使用，提供了统一的API。
>3. 提供丰富的功能：Axios支持GET、POST、PUT、DELETE等多种HTTP请求方法，可以发送JSON数据、表单数据、文件等，并可以设置请求头、超时时间等参数。
>4. 拦截器：Axios提供了请求和响应的拦截器，可以在发送请求之前和处理响应之前进行一些操作，如添加认证信息、处理错误等。
>5. 取消请求：Axios支持取消请求，可以中断正在进行的请求。
>6. 自动转换数据：Axios可以自动将响应数据转换为JSON对象，也可以自定义数据转换逻辑。
>7. 提供进度监测：Axios可以监测上传和下载的进度，提供了进度事件供开发者使用。
>
>通过使用Axios，开发者可以更方便地进行HTTP请求的发送和处理，并且具有良好的可扩展性和灵活性。它已经成为前端开发中最受欢迎的HTTP客户端库之一。



Ajax和 jquey的区别

>
>
>Axios和jQuery是两个不同的库，它们在功能和设计理念上有一些区别。
>
>1. 用途：Axios专注于处理HTTP请求，它提供了更简洁和专注的API，使得发送和处理HTTP请求更加方便。而jQuery是一个综合性的JavaScript库，它包含了很多功能模块，包括DOM操作、事件处理、动画效果等，其中也包含了对Ajax请求的支持。
>
>2. 大小：Axios相对于jQuery来说更轻量，它只专注于HTTP请求的处理，因此它的文件大小更小，加载速度更快。
>
>3. API设计：Axios的API设计更加现代化和符合最新的JavaScript标准，它基于Promise和异步/await进行异步操作的处理。而jQuery的Ajax API则是基于回调函数的方式。
>
>4. 依赖性：Axios不依赖于其他库或框架，可以单独使用。而jQuery是一个全功能的库，它包含了很多其他功能模块，使用jQuery的Ajax功能需要引入整个jQuery库。
>
>5. 浏览器和环境支持：Axios可以在浏览器和Node.js环境中使用，而jQuery的Ajax功能更常用于浏览器端。
>
>总的来说，Axios是一个专注于处理HTTP请求的现代化库，而jQuery则是一个功能较为全面的JavaScript库，其中包含了对Ajax请求的支持。选择使用哪个库取决于项目需求和个人偏好，如果只需要处理HTTP请求，可以选择使用Axios来获得更轻量和现代化的解决方案。





### 如果使用同样的功能，导入库文件越小，速度更快是吗



通常情况下，导入文件大小较小的库会具有更快的加载速度，这是因为较小的文件需要下载和解析的时间更短。

当加载网页时，浏览器需要下载和解析所引用的库文件，然后才能执行相关的代码。如果库文件较大，下载和解析的时间会更长，从而导致整个页面的加载速度变慢。

另外，较小的库文件通常意味着它们具有更少的功能和依赖关系。这意味着浏览器只需加载和处理必要的代码，而无需加载额外的功能模块或依赖项，从而提高了整体的执行效率。

因此，选择较小的库文件可以在一定程度上提高网页的加载速度和执行效率。然而，这也要考虑到功能需求和代码的维护性，确保所选择的库能够满足项目的需求，并且易于使用和维护。





## 请求头内容一般不写中文

>在发送请求的请求头信息中，通常使用的是 ASCII 字符集，它是一种基本的字符编码标准，包含了大部分常用的英文字母、数字、标点符号等字符。
>
>虽然 HTTP 协议本身是支持在请求头中使用中文字符的，但是由于历史原因和一些特殊情况，某些服务器、代理服务器或中间件可能不支持或不正确地处理包含非 ASCII 字符的请求头信息。为了避免出现不兼容或错误的情况，一般建议在请求头中使用 ASCII 字符集的字符。
>
>如果需要在请求头中传递中文字符或其他非 ASCII 字符，通常会采用编码方式进行处理，比如使用 URL 编码或 Base64 编码将非 ASCII 字符转换为 ASCII 字符，然后在请求头中发送编码后的值。
>
>例如，可以使用 `encodeURIComponent()` 函数对中文字符进行 URL 编码，然后将编码后的值放入请求头中：
>
>```javascript
>headers: {
>  'Content-Type': 'application/json',
>  'Authorization': 'Bearer ' + encodeURIComponent('中文字符')
>}
>```
>
>需要注意的是，服务器端在接收到请求头后，也需要进行相应的解码操作才能正确地获取到原始的中文字符。因此，双方需要在编码和解码方面保持一致，以确保请求头信息的准确传递和处理。
>
>采用编码的形式， 服务器进行解码操作获得中文字符



## 同源策略

>
>
>同源策略（Same-Origin Policy）是一种浏览器安全机制，用于限制来自不同源（即不同协议、域名或端口）的网页对当前网页的访问。同源策略旨在防止跨站点脚本攻击（Cross-Site Scripting, XSS）和跨站点请求伪造（Cross-Site Request Forgery, CSRF）等安全漏洞。
>
>根据同源策略，浏览器允许当前网页的脚本只与来自相同源的资源进行交互，而限制与来自不同源的资源进行交互。同源策略涵盖了许多方面，包括 JavaScript 访问其他网页的 DOM、发送 AJAX 请求、共享 Cookie 等。
>
>为了满足同源策略，请求必须满足以下三个条件，被认为是同源的：
>
>1. 协议相同：两个页面的协议必须相同，如都是 http:// 或都是 https://。
>2. 域名相同：两个页面的域名必须相同，如都是 example.com。
>3. 端口相同：如果指定了端口号，则两个页面的端口号必须相同，否则默认使用80端口（http）或443端口（https）。
>
>如果请求不符合同源策略的要求，浏览器将阻止对资源的访问，并在控制台输出相应的错误信息。
>
>需要注意的是，同源策略是由浏览器实施的安全机制，不是由服务器端控制的。服务器端仍然可以发送响应，但浏览器会限制网页对该响应的访问。为了实现跨域访问，可以通过使用 CORS（跨域资源共享）机制或代理服务器等方法来解决同源策略的限制。





## 使用 Express 框架创建了一个 Node.js 的服务器应用(代码解析)

>这段代码使用了 Express 框架创建了一个 Node.js 的服务器应用。让我逐行解析这段代码的含义：
>
>1. `const express = require('express');`: 引入 Express 框架，将其赋值给变量 `express`。
>
>2. `const app = express();`: 创建一个 Express 应用实例，将其赋值给变量 `app`。
>
>3. `app.get('/home', (req, res) => { ... });`: 定义一个 GET 请求的路由处理器。当客户端以 GET 方法请求 `/home` 路径时，该处理器将被执行。
>
>4. `(req, res) => { ... }`: 这是一个箭头函数，用于处理请求和响应。`req` 参数是一个包含了客户端请求信息的对象，`res` 参数是一个用于发送响应的对象。
>
>5. `res.sendFile(__dirname + '/index.html');`: 使用 `res.sendFile` 方法发送一个文件作为响应。**`__dirname` 是一个 Node.js 中的全局变量，表示当前脚本所在的目录**。这里的 `/index.html` 表示要发送的文件路径，它会被解析为当前脚本所在目录下的 `index.html` 文件。
>
>这段代码的作用是当客户端以 GET 方法请求 `/home` 路径时，服务器将发送一个名为 `index.html` 的文件作为响应。这样客户端在浏览器中访问 `/home` 路径时，将会看到 `index.html` 页面的内容。
>
>需要注意的是，这段代码仅仅是 Express 应用的一部分，还需要在代码的后面通过 `app.listen` 方法指定服务器监听的端口，才能使服务器真正运行起来。例如：
>
>```
>app.listen(8000, () => {
>  console.log('Server is running on port 8000');
>});
>```
>
>这样服务器将在本地的 8000 端口上监听请求，并在控制台输出 "Server is running on port 8000" 的消息。



## JSONP 函数调用

>
>
>JSONP（JSON with Padding）是一种在跨域请求中使用的技术，允许在浏览器中从不同的域获取数据。它通过动态创建 `<script>` 标签来实现跨域请求，并利用回调函数来处理返回的数据。
>
>下面是使用 JSONP 的基本步骤：
>
>1. 在前端页面中定义一个全局的回调函数，用于处理返回的数据。例如：
>
>   ```javascript
>   function handleResponse(data) {
>     // 处理返回的数据
>     console.log(data);
>   }
>   ```
>
>2. 创建一个 `<script>` 标签，并将其 `src` 属性设置为包含回调函数的 URL。在 URL 的参数中指定回调函数的名称。例如：
>
>   ```javascript
>   const script = document.createElement('script');
>   script.src = 'http://example.com/api/data?callback=handleResponse';
>   document.body.appendChild(script);
>   ```
>
>   在这个例子中，`handleResponse` 是前面定义的回调函数。
>
>3. 服务器接收到请求后，将数据包装在回调函数中返回给前端。例如，服务器返回的响应如下：
>
>   ```javascript
>   handleResponse({ name: 'John', age: 25 });
>   ```
>
>4. 前端浏览器接收到响应后，会自动执行回调函数 `handleResponse`，并传入服务器返回的数据作为参数。
>
>请注意，**JSONP 只支持 GET 请求**，因为它是通过动态创建 `<script>` 标签实现的，而 `<script>` 标签只能发起 GET 请求。此外，JSONP 的使用需要服务器端支持，并且需要确保服务器端返回的数据符合 JSONP 的格式。
>
>JSONP 目前已经被 CORS（跨域资源共享）所取代，CORS 提供了更灵活和安全的跨域请求机制。但在某些情况下，仍然可以使用 JSONP 进行跨域请求，尤其是在需要兼容老旧浏览器或无法修改服务器端配置的情况下。



### jsonp通过返回一个函数，来达到目的

>
>
>是的，JSONP 通过返回一个函数来实现跨域请求。具体而言，服务器返回的响应是一个函数调用，该函数作为参数传递给前端，前端浏览器接收到响应后直接执行该函数。
>
>以下是一个示例，演示如何使用 JSONP 进行跨域请求：
>
>前端代码：
>```javascript
>function handleResponse(data) {
>  // 处理返回的数据
>  console.log(data);
>}
>
>const script = document.createElement('script');
>script.src = 'http://example.com/api/data?callback=handleResponse';
>document.body.appendChild(script);
>```
>
>在上面的例子中，服务器返回的响应是一个函数调用，例如：
>```javascript
>handleResponse({ name: 'John', age: 25 });
>```
>
>前端浏览器接收到响应后，会自动执行 `handleResponse` 函数，并将服务器返回的数据作为参数传递给该函数。
>
>需要注意的是，服务器端需要根据请求参数中的 `callback` 参数来动态生成响应，将数据包装在该参数指定的函数调用中返回给前端。
>
>这种方式允许跨域请求，因为 `<script>` 标签的 `src` 属性可以加载来自其他域的脚本文件，但是仅限于 GET 请求。同时，JSONP 也存在一些安全风险，因为服务器返回的脚本会在前端执行，所以需要确保从服务器获取的脚本是可信的。
>
>

**函数内部的参数为我们所要的数据，因为script不能直接识别数据，只能通过这种函数调用的形式，包裹返回**

>是的，您理解得很正确。由于 `<script>` 标签只能加载并执行脚本文件，无法直接获取返回的数据，因此 JSONP 通过将数据包裹在函数调用中返回，以便前端可以通过函数的参数获取到所需的数据。
>
>在 JSONP 请求中，服务器端会根据请求参数中的 `callback` 参数动态生成响应，将数据作为参数传递给该参数指定的函数调用。前端浏览器接收到响应后，会执行该函数，并在执行过程中获取到服务器返回的数据。
>
>这种通过函数调用包裹数据的方式，使得前端能够间接地获取跨域请求的数据，并在回调函数中进行处理。这也是 JSONP 的一种特殊机制，与传统的 AJAX 请求不同。



## json字符串 返回后执行

>
>
>当使用 JSONP 进行跨域请求时，服务器返回的是一个包裹了数据的 JavaScript 函数调用，而不仅仅是纯粹的 JSON 字符串。这个函数调用是在前端页面中动态创建的 `<script>` 标签加载并执行的。
>
>例如，在您的例子中，返回的字符串是 `handle({"name":"韩绝"})`。前端页面会将该字符串作为脚本执行，并执行 `handle()` 函数，将 JSON 对象 `{"name":"韩绝"}` 作为参数传递给该函数。
>
>由于返回的字符串被视为 JavaScript 代码执行，所以其中的函数调用会被解析和执行，而不仅仅是简单地将其作为字符串返回给前端。这样可以确保将数据传递给前端页面，并让页面中的回调函数能够正确地处理该数据。



>当返回的 JSONP 字符串被执行时，其中的函数调用会自动解析和执行。在您的例子中，返回的字符串 `handle({"name":"韩绝"})` 会触发前端页面中名为 `handle` 的函数调用，并将 `{"name":"韩绝"}` 作为参数传递给该函数。
>
>在函数内部，您可以通过参数 `data` 来访问传递的数据。在您的例子中，`data.name` 将被设置为 `"韩绝"`，然后可以在前端页面中进行处理，例如将该值设置到特定的 HTML 元素中。
>
>通过这种方式，JSONP 实现了跨域请求并将数据传递给前端页面的机制。前端页面需要提前定义一个名为 `handle` 的函数，并确保服务器返回的 JSONP 字符串中包含该函数调用，以便正确处理返回的数据。





##  jQuery 的 JSONP 方法发起请求并获取数据

**代码解析**

>这段代码演示了使用 jQuery 的 JSONP 方法发起请求并获取数据的过程。以下是对代码的解析：
>
>服务端代码：
>- 创建了一个 `/jquery-jsonp-server` 的路由，用于处理 jQuery 的 JSONP 请求。
>- 构造了一个包含名称和城市数组的数据对象。
>- 将数据对象转换为字符串。
>- 从请求的 query 参数中获取回调函数的名称。
>- 将回调函数名称和数据字符串拼接成返回的结果，并通过 `res.end()` 方法返回给客户端。
>
>客户端代码：
>- 绑定一个点击事件处理程序，当按钮被点击时触发。
>- 使用 `$.getJSON()` 方法发起跨域的 JSONP 请求。
>- 请求的 URL 为 `http://127.0.0.1:8000/jquery-jsonp-server?callback=?`，其中 `callback=?` 表示告诉服务器返回的数据需要包裹在回调函数中。
>- 在请求成功后的回调函数中，通过参数 `data` 获取服务器返回的数据。
>- 将返回的数据显示在页面中的 `#result` 元素中。
>
>当按钮被点击时，jQuery 会自动构建一个带有随机生成的回调函数名称的请求 URL，并发送给服务器。服务器返回的数据会被包裹在回调函数中，并通过 `$.getJSON()` 方法的回调函数参数传递给客户端，从而可以在回调函数中处理返回的数据。
>
>需要注意的是，服务器端返回的数据需要使用回调函数名称将数据包裹起来，这样客户端才能正确解析并处理返回的数据。在客户端的回调函数中，可以直接通过 `data` 参数获取到解析后的对象，无需手动解析。



## cors

>
>
>CORS（Cross-Origin Resource Sharing）是一种用于解决跨域请求的机制。跨域请求是指在浏览器中，通过 JavaScript 从一个源（域、协议、端口）向另一个源发送请求。CORS 提供了一种方式，让服务器在响应中声明允许跨域请求的权限，以便浏览器可以安全地处理跨域请求。
>
>CORS 的工作原理如下：
>1. 客户端发起跨域请求，发送请求到目标服务器。
>2. 服务器接收到请求后，在响应头中添加 CORS 相关的信息。
>3. 浏览器接收到响应后，根据响应头中的 CORS 信息判断是否允许跨域请求。
>4. 如果允许跨域请求，浏览器将响应数据返回给客户端，JavaScript 可以处理响应数据。
>5. 如果不允许跨域请求，浏览器会阻止 JavaScript 访问响应数据，JavaScript 无法处理响应数据。
>
>常见的 CORS 相关的响应头字段包括：
>- Access-Control-Allow-Origin：指定允许跨域请求的源（域、协议、端口）。
>- Access-Control-Allow-Methods：指定允许的请求方法。
>- Access-Control-Allow-Headers：指定允许的请求头信息。
>- Access-Control-Max-Age：指定预检请求的有效期。
>
>通过在服务器的响应中设置适当的 CORS 头信息，可以控制跨域请求的访问权限，从而实现安全的跨域数据交互。
>
>需要注意的是，CORS 只在浏览器环境中起作用，对于其他非浏览器环境（如服务器之间的请求）不会进行 CORS 相关的处理。



END: 6:11- 3:32
